/*
 * 	Base64, Base32 and Base16 encodings as they are standarized 
 *	by rfc4648 of 2006.
 *
 *	@TODO: make some utilities functions for encoding text files directly
 *		   these will be helper utilities,one utitlity could return a pointer
 *		   to a struct with the info of how many bytes is the total encoded
 *		   and a pointer to memory where is stored.
 *
 *	There are several versions in this file, some are intended to encode 
 *	only text and the others encode any type of input, like binary (images,
 *	executables, etc.) [1].
 *
 *	[1] b64_enc, b64_dec, b32_enc and b32_dec are general purpose base64
 *		and base32 encoding and decoding functions, with support for binary
 *		input and every type of input including text. All others functions 
 *		work on text input only.
 *
 *	Orestes Leal Rodriguez 2015 <lukes357@gmail.com>
 *
 *	±devlog
 *		Aug 2: initial revision, base16 and base64 text encoding
 *		Aug 3: support for escaped characters on base64_enc
 *		Aug 6: added base64 text decoding 
 *		Aug 7: added base64url encoding/decoding
 *		Aug 8: added a base64 encoder for all file formats, incl binary,
 *   	       this new version is named 'b64_enc' named so to not break
 *   	  	   the existing utilities that use 'base64_enc', if one is 
 * 			   encoding text files with escapes characters like the ones
 * 			   used to generate auth strings for the AUTH PLAIN SMTP command, 
 *			   then 'base64_enc' is the more appropiate, otherwise this 
 *			   encoder will suffice, also is more efficient, clear, and fast.
 *		Aug 9: some small optimizations to b64_enc
 *			   added a universal base64 decoder named 'b64_dec'
 *			   which can decode pretty much everything from base64
 *			   encoded text strings to binary images or executables,
 *			   after decoding it returns the number of bytes that
 *			   were encoded in the base64 string, this is useful for
 *			   example in a mail client where an email with an image
 *			   as an attachment is encoded in base64 but the size of
 *			   the output image isn't known, with this return value the
 *			   original file can be saved to disk specifying the number
 *			   of bytes to write.
 *	   Aug 10: b64_dec: Added optimizations to compute length of the encoded
 *			   data outside the decoding loop
 *			   Added a function (get_data_size) to get the size in bytes 
 *			   of the data encoded in a base64 string
 *	   Aug 12: general purpose base32 encoding supported (b32_enc)
 *			   good optimizations added for base32 encoding 
 *	   Aug 13: general purpose base32 decoder added (b32_dec)
 *	   Aug 14: b32_dec now returns the size of the data decoded 
 *	   		   Integrate the get_token_pos() code into b32_dec for avoiding
 *			   the overhead of the function call
 *			   
 */
#define ESC '\\'
#define PAD '='
/* alphabets for b32, b64 and b64url */ 
char b64_alp[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
char b64_url_alp[64] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
char b32_alp[32] = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";

/* get the position of the character 'tk' on the alphabet
   'alp' and test at most 'len' positions on it */
static inline unsigned char get_token_pos(char tk, unsigned char len, char alp[])
{
	unsigned char pos, lim;
	for (pos = 0, lim = len; tk != alp[pos] && lim; ++pos, lim--) ;
	return pos <= len ? pos : 0;
}
/* Base 64 decoding with URL and Filenamee Safe Alphabet */
void base64url_dec(char *s, char b[])
{
	unsigned int x;
	int i,z,w;

	x = w = 0;
	for (i = 0; s[i] != PAD && s[i]; i++) {
		for (x = 0, z = 0; z < 4 && s[i] && s[i] != PAD; z++) {
			x |= get_token_pos(s[i++], 64, b64_url_alp);
			z < 3 && s[i] != PAD && s[i] ? x <<= 6 : 0;
		}
		/*  if there are less than 24 bits of input, add 0s on 
			the right to make an integral number of 6 bit groups 
			(sec. 4. rfc4648 */
		for (;z < 4; z++, x <<= 6);  
		x <<= 8;
		b[w++] = x >> 24;
		b[w++] = (x << 8) >> 24;
		b[w++] = (x << 16) >> 24;
		--i;
	}
	b[w] = '\0';
}
/* Base 64 encoding with URL and Filenamee Safe Alphabet */
void base64url_enc(char *s, char b[])
{
	unsigned int x, npad;
	int i;

	npad = 0;
	for (i = 0; *s; i++) {
		x = s[0] == ESC ? s++[1]-'0' : s[0];
		x <<= 8;
		x |= s[1] == ESC ? s++[2]-'0' : s[1];
		x <<= 8;
		x |= s[2] == ESC ? s++[3]-'0' : s[2];
		x <<= 8;
		b[i++] = b64_url_alp[x >> 26];
		b[i++] = b64_url_alp[(x << 6) >> 26];

		if (s[1] == '\0') { /* quantum of encoding of 8 bits */
			npad = 2;
			break;
		}
		b[i++] = b64_url_alp[(x << 12) >> 26];
		
		if (s[2] == '\0') { /* quantum of 16 bits */
			npad = 1;
			break;
		}
		b[i] = b64_url_alp[(x << 18) >> 26];
		s += 3; /* point to the next 24 bit group */ 
	}
	for (;npad > 0; npad--) { /* add padding if needed */
		b[i++] = PAD;
	}
	b[i] = '\0';
}
/* decode a base64 string into the original text string */
void base64_dec(char *s, char b[])
{
	unsigned int x;
	int i,z, w;

	x = w = 0;
	for (i = 0; s[i] != PAD && s[i]; i++) {
		for (x = 0, z = 0; z < 4 && s[i] && s[i] != PAD; z++) {
			x |= get_token_pos(s[i++], 64, b64_alp);
			z < 3 && s[i] != PAD && s[i] ? x <<= 6 : 0;
		}
		/*  less than 24 bits of input, add 0s on the right to make
			an integral number of 6 bit groups (sec. 4. rfc4648 */
		for (;z < 4; z++, x <<= 6);  
		x <<= 8;
		b[w++] = x >> 24;
		b[w++] = (x << 8) >> 24;
		b[w++] = (x << 16) >> 24;
		--i;
	}
	b[w] = '\0';
}
/* encode a text string or text file into base64 */
void base64_enc(char *s, char b[])
{
	unsigned int x, npad;
	int i;

	npad = 0;
	for (i = 0; *s; i++) {
		x = s[0] == ESC ? s++[1]-'0' : s[0];
		x <<= 8;
		x |= s[1] == ESC ? s++[2]-'0' : s[1];
		x <<= 8;
		x |= s[2] == ESC ? s++[3]-'0' : s[2];
		x <<= 8;
		b[i++] = b64_alp[x >> 26];
		b[i++] = b64_alp[(x << 6) >> 26];

		if (s[1] == '\0') { /* quantum of encoding of 8 bits */
			npad = 2;
			break;
		}
		b[i++] = b64_alp[(x << 12) >> 26];
		
		if (s[2] == '\0') { /* quantum of 16 bits */
			npad = 1;
			break;
		}
		b[i] = b64_alp[(x << 18) >> 26];
		s += 3; /* point to the next 24 bit group */ 
	}
	for (;npad > 0; npad--) { /* add padding if needed */
		b[i++] = PAD;
	}
	b[i] = '\0';
}
void base16_encoder(char *s, char b[])
{
	char b16_alp[] = "0123456789ABCDEF";
	int i;
	for (i = 0; *s; i++, s++) { 
		unsigned char x = (unsigned char)*s >> 4;
		unsigned char z = ((unsigned char)(*s << 4)) >> 4;
		b[i] = b16_alp[x];
		b[++i] = b16_alp[z];
	}
	b[i] = '\0';
}
void base16_decoder(char *b16, char b[])
{
	int i;
	unsigned char n1, n2;
	for (i = 0; *b16; i++, b16+=2) {
		if (*b16  < 'A') {
			n1 = (*b16 - '0') << 4;
		}
		else {
			n1 = (*b16 - 0x37) << 4;
		}
		if (*(b16 + 1) < 'A') {
			n2 = *(b16 + 1) - '0';
		}
		else {
			n2 = *(b16 + 1) - 0x37;
		}
		b[i] =  n1 | n2;
	}
	b[i] = '\0';
}
/* general purpose base64 encoding */
void b64_enc(unsigned const char *s, char b[], unsigned int len)
{
	register unsigned int x,i,w;
	unsigned char rm,z;

	w = 0;
	for (i = 0; i < len; i++) {
		for (x = 0, z = 0; z < 3 && i < len; z++, i++) {
			x |= s[i];	
			(z < 2 && i+1 < len) ? x <<= 8 : 0;
		}
		for (;z < 4; z++, x <<= 8);
		b[w++] = b64_alp[x >> 26];
		b[w++] = b64_alp[(x << 6) >> 26];
		b[w++] = b64_alp[(x << 12) >> 26];
		b[w++] = b64_alp[(x << 18) >> 26];
		--i;
	}
	b[w] = '\0';
	rm = len % 3; 
	if (rm) { /* padding */ 
		for (x = rm == 1 ? 2 : 1; x; --x) {
			b[--w] = PAD;
		}
	}
}
/* general purpose base64 decoding */
unsigned int b64_dec(unsigned char *s, char b[], unsigned int len)
{
	unsigned int x,w,i,rtsize,z;
	unsigned char pad = 0;

	/* remove trailing padding and get the number of them (2 or 1) */
	for (i = len-1; s[i] == PAD; --i) {
		++pad;
		--len;
	}
	w = 0;
	for (i = 0; i < len; i++) {
		for (x = 0, z = 0; z < 4 && i < len; z++, i++) {
			x |= get_token_pos(s[i], 64, b64_alp);
			z < 3 && i+1 < len ? x <<= 6 : 0;
		}
		for (;z < 4; z++, x <<= 6);
		x <<= 8;
		b[w++] = x >> 24;
		b[w++] = (x << 8) >> 24;
		b[w++] = (x << 16) >> 24;
		--i;
	}
	rtsize = (len >> 2) * 3;
	if (pad) {
		rtsize += pad == 2 ? 1 : 2;
	}
	b[rtsize] = '\0';
	return rtsize; /* number of decoded bytes */
}
/* get the size of the encoded data in a base64 string */
unsigned int get_data_size(char *s, unsigned int len)
{
	unsigned int rtsize, i;
	unsigned char pad = 0;
	for (i = len-1; s[i] == PAD; --i) {
		++pad;
		--len;
	}
	rtsize = (len >> 2) * 3;
	if (pad) {
		rtsize += pad == 2 ? 1 : 2;
	}
	return rtsize;
}
/* general purpose Base32 encoding */ 
void b32_enc(unsigned char *s, unsigned char *b, unsigned int len)
{
	unsigned long long x;	/* c99 only */
	unsigned int i,w,z;
	unsigned char ap[5] = {0,6,4,3,1};

	w = x = 0;
	/* 	in base32 per 5 bytes of input we get 40 bits that must
		be treated as eight 5 bits groups, each 5 bit number
		will be used as an index into the base32 alphabet  */
	for (i = 0; i < len; i++) {
		for (z = 0; z < 5 && i < len; z++, i++) {
			x |= s[i];
			x <<= 8;
		}
		/* compute the number of shifts needed to align all bytes
			to the most significant part of x, this avoids several
			iterations of one 'test, shift, and increment' loop */
		x <<= (7 - z) << 3; /* mul by 8 */ 

		/* 	this block could be optimized for size within a loop, but that
			will involve a and additional 'test and increment' step on a 
			loop, which will make the code a tiny fraction more slower,
			this is coded for speed, not size */
		b[w++] = b32_alp[x >> 59];
		b[w++] = b32_alp[(x << 5) >> 59];
		b[w++] = b32_alp[(x << 10) >> 59];
		b[w++] = b32_alp[(x << 15) >> 59];
		b[w++] = b32_alp[(x << 20) >> 59];
		b[w++] = b32_alp[(x << 25) >> 59];
		b[w++] = b32_alp[(x << 30) >> 59];
		b[w++] = b32_alp[(x << 35) >> 59];
		--i;
	}
	b[w] = '\0';
	for (i = ap[len % 5]; i; i--) {
		b[--w] = PAD; 
	}		
	return;
}
/* general purpose Base32 decoding */
unsigned int b32_dec(unsigned char *s, unsigned char *b, unsigned int len)
{
	unsigned long long x;
	unsigned int i,w,z, rtsize;
	unsigned char pad,t,l;
	/* 	lookup table used as an index with the value of 'pad' 
		to help calculate the size of the encoded data */
	unsigned char lkpad[7] = {0,4,0,3,2,0,1};

	for (pad = 0,i = len-1; s[i] == PAD; i--) {
		++pad;
		--len;
	}
	w = 0;
	for (i = 0; i < len; i++) {
		for (x = 0, z = 0; z < 8 && i < len; z++, i++) {
			for (t = 0, l = 31; (s[i] != b32_alp[t]) && l; t++, l--);
			x |= t;
			x <<= 5;
		}
		/* 	compute the shifting needed to align the input
			into the msb */
		x <<= (19 + ((8-z)*5)); 
		b[w++] = x >> 56; 
		b[w++] = (x << 8) >> 56;
		b[w++] = (x << 16) >> 56;
		b[w++] = (x << 24) >> 56;
		b[w++] = (x << 32) >> 56;
		--i;
	}
	/* divide the length by 8 and multiply the result
	   by 5, then adding the value of 'pad' indexed into
	   'lkpad' computes the size of the encoded data.
	   shr by 3 is the same as "len / 8" */
	rtsize = (len >> 3) * 5 + lkpad[pad]; 
	b[rtsize] = '\0';
	return rtsize;
}
